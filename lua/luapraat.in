#include "melder.h"
#include "praat_script.h"
#include "praatP.h"
#include "luapraat.h"

// NOTE: can't directly set to theInterpreter from Formula.cpp because
// that's static
static Interpreter INTERPRETER;
static PraatObjects PRAAT_OBJECTS = theCurrentPraatObjects;
extern structMelderDir praatDir;
static const char *LUAPRAAT_LUALIB = R"(include_str!("praat.lua");)";

// Run a single Praat command and return the value it yields.
static int luapraat_praat_cmd(lua_State *L) {
	static MelderString output;
	const char *cmd_c = lua_tostring(L, 1);
	autostring32 cmd = Melder_8to32(cmd_c);

	bool should_divert = !(
		// obviously, if the user is trying to write to the info window, the
		// output shouldn't be diverted
		str32nequ(cmd.get(), U"appendInfo", 10)
		|| str32nequ(cmd.get(), U"writeInfo", 9)
	);
	// TODO: create an API for this buffer switch back and forth, instead
	// of directly meddling with _p_currentBuffer and _foregroundBuffer?
	MelderString *orig_current_buffer = MelderInfo::_p_currentBuffer;
	if (should_divert) {
		MelderString_empty(&output);
		// sentinel which indicates current object ID should be returned
		// instead; will be overwritten if any actual output is generated
		MelderString_appendCharacter(&output, 1);
		MelderInfo::_p_currentBuffer = &output;
	} else {
		MelderInfo::_p_currentBuffer = &MelderInfo::_foregroundBuffer;
	}

	bool cmd_failed = false;
	bool no_silent_error;
	// praat_executeCommand returns 0 if an error occurred and was
	// silenced using nocheck, 1 otherwise. The 0 shouldn't happen too
	// often, since when calling Praat from Lua, it's better to use Lua's
	// exception handling facilities: instead of `_praat("nocheck X")`, do
	// `pcall(praat.X)`.  But let's handle it the same way Interpreter.cpp
	// does, for consistency's sake.
	try {
		no_silent_error = praat_executeCommand(INTERPRETER, cmd.get());
	} catch (MelderError) {
		cmd_failed = true;
	}
	// reset to old divert (if any, otherwise to regular info window)
	// instead of Melder_divertInfo(nullptr), which would ignore any old
	// divert
	MelderInfo::_p_currentBuffer = orig_current_buffer;
	if (cmd_failed) {
		return luaL_error(L, "Praat command failed: `%s`", cmd_c);
	}

	if (should_divert && no_silent_error) {
		if (output.string[0] == 1) {
			// output starts with special sentinel -> return a Lua array with
			// the currently selected objects instead of it
			lua_newtable(L);                                                   // A: array with all selected objects
			lua_Integer j = 0;
			for (int i = 1; i <= PRAAT_OBJECTS->n; i++) {
				praat_Object obj = &PRAAT_OBJECTS->list[i];
				if (obj->isSelected) {
					lua_newtable(L);                                               // O: object being added to A
					lua_pushnumber(L, obj->id);
					lua_setfield(L, -2, "id");                                     // -2 is O
					lua_pushstring(L, Melder_32to8(obj->name.get()).get());
					lua_setfield(L, -2, "name");                                   // -2 is O
					lua_rawseti(L, -2, ++j);                                       // -2 is A
				}
			}
		} else {
			lua_pushstring(L, Melder_32to8(output.string).get());
		}
	} else {
		lua_pushnil(L);
	}
	return 1;
}

// Run a (multi-line) Praat script, purely for its side effects.
static int luapraat_praat_script(lua_State *L) {
	const char *script_c = lua_tostring(L, 1);
	autostring32 script = Melder_8to32(script_c);
	try {
		Interpreter_run(INTERPRETER, script.get());
	} catch (MelderError) {
		return luaL_error(L, "Praat script failed: `%s`", script_c);
	}
	return 0;
}

static lua_State *luapraat_setup(Interpreter interpreter) {
	// TODO: is there maybe a cleaner way to pass the interpreter to the
	// C/Lua interface function than via a global?
	INTERPRETER = interpreter;
	// If info output is currently redirected to a string (from which
	// we'll later read the result of the Lua script), reset the string
	// so as to clear out the sentinel value placed there to check
	// whether the command generated output. If the output is *not*
	// redirected, we don't want to force-clear the Info window, so
	// leave it alone. This is the difference between "x = Lua ..." vs.
	// "Lua ..." in the Praat script.
	if (MelderInfo::_p_currentBuffer != & MelderInfo::_foregroundBuffer) {
		MelderInfo_open ();
	}

	// TODO: create a C++ wrapper for lua_State which will be moved
	// between functions and have a destructor which clears the stack and
	// calls lua_close?
	lua_State *L = luaL_newstate();
	luaL_openlibs(L);

	lua_pushstring(L, Melder_peek32to8_fileSystem(Melder_dirToPath(&praatDir)));
	lua_setglobal(L, "PRAAT_DIR");

	lua_pushcfunction(L, luapraat_praat_cmd);
	lua_setglobal(L, "_praat_cmd");
	lua_pushcfunction(L, luapraat_praat_script);
	lua_setglobal(L, "_praat_script");

	luaL_dostring(L, LUAPRAAT_LUALIB);
	lua_setglobal(L, "praat");

	// prepare a traceback error handler to hook up with the last arg to
	// pcall in luapraat_do_run
	lua_getglobal(L, "debug");
	lua_getfield(L, -1, "traceback");
	lua_remove(L, -2);

	return L;
}

static void luapraat_do_run(lua_State *L, int load_error) {
	if (load_error) {
		autostring32 msg = Melder_8to32(lua_tostring(L, -1));
		lua_settop(L, 0);
		lua_close(L);
		Melder_throw(U"Error loading Lua script ", msg.get());
	}

	// at this point, the chunk to call should be at the top of the stack,
	// and the traceback error handler just below it, hence the final -2
	int call_error = lua_pcall(L, 0, LUA_MULTRET, -2);
	if (call_error) {
		autostring32 msg = Melder_8to32(lua_tostring(L, -1));
		lua_settop(L, 0);
		lua_close(L);
		Melder_throw(U"Error running Lua script ", msg.get());
	}

	// If the chunk returns anything, this is how Praat will receive it if
	// called from Praat script as `x = Lua ...`, via diverted info output.
	// NOTE: The conversion assumes UTF-8 output from Lua.
	MelderInfo_write(Melder_8to32(lua_tostring(L, -1)).get());
	lua_settop(L, 0);
	lua_close(L);
}

void luapraat_run_file(const char32 *script_path, Interpreter interpreter) {
	lua_State *L = luapraat_setup(interpreter);
	const char *script_path_fs = Melder_peek32to8_fileSystem(script_path);
	luapraat_do_run(L, luaL_loadfile(L, script_path_fs));
}

void luapraat_run_chunk(const char32 *chunk, Interpreter interpreter) {
	lua_State *L = luapraat_setup(interpreter);
	luapraat_do_run(L, luaL_loadstring(L, Melder_32to8(chunk).get()));
}

// vi: ft=cpp:
