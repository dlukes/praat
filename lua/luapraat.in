#include "melder.h"
#include "praat_script.h"
#include "luapraat.h"

static const char *LUAPRAAT_LUALIB = R"(include_str!("praat.lua");)";
Interpreter *INTERPRETER;

static int luapraat_call_praat(lua_State *L) {
	static MelderString output;
	autostring32 cmd = Melder_8to32(lua_tostring(L, 1));

	bool should_divert = !str32nequ(cmd.get(), U"appendInfo", 10) && !str32nequ(cmd.get(), U"writeInfo", 9);
	MelderString *old_divert;
	if (should_divert) {
		MelderString_empty(&output);
		// TODO: encapsulate getting current buffer in a function instead of
		// direct access?
		old_divert = MelderInfo::_p_currentBuffer;
		MelderInfo::_p_currentBuffer = &output;
	}

	// TODO: what does the status tell us, what should we do with it?
	// TODO: if there's a problem running the command, the exception
	// currently doesn't propagate appropriately and instead, the program
	// crashes with SIGABRT; how to avoid that?
	int status = praat_executeCommand(*INTERPRETER, cmd.get());

	if (should_divert) {
		lua_pushstring(L, Melder_32to8(output.string).get());
		// reset to old divert (if any, otherwise to regular info window)
		// instead of Melder_divertInfo(nullptr), which would ignore any old
		// divert
		MelderInfo::_p_currentBuffer = old_divert;
	} else {
		lua_pushnil(L);
	}
	return 1;
}

autostring32 luapraat_run(const char32 *script_path, Interpreter *interpreter) {
	lua_State *L = luaL_newstate();
	luaL_openlibs(L);
	lua_pushcfunction(L, luapraat_call_praat);
	lua_setglobal(L, "_praat");
	luaL_dostring(L, LUAPRAAT_LUALIB);
	lua_setglobal(L, "praat");
	// TODO: is there a cleaner way to pass the interpreter to the C/Lua
	// interface function than via a global? This isn't re-entrant.
	INTERPRETER = interpreter;

	const char *script_path_fs = Melder_peek32to8_fileSystem(script_path);
	int load_error = luaL_loadfile(L, script_path_fs);
	if (load_error) {
		// If something went wrong, error message is at the top of the stack
		Melder_throw(U"Couldn't load file: ", Melder_8to32(lua_tostring(L, -1)).get());
	}

	int call_error = lua_pcall(L, 0, LUA_MULTRET, 0);
	if (call_error) {
		Melder_throw(U"Failed to run script: ", Melder_8to32(lua_tostring(L, -1)).get());
	}

	const char *result_c = lua_tostring(L, -1);
	autostring32 result;
	// If there is no output but MelderInfo is diverted (= Praat is
	// expecting a return value), signal to Praat we want to "return" the
	// current Praat object, using the sentinel value expected by
	// Interpreter_run.
	if (result_c == nullptr && MelderInfo::_p_currentBuffer != & MelderInfo::_foregroundBuffer) {
		result = Melder_8to32("\x01");
	} else {
		// NOTE: The conversion assumes UTF-8 output from Lua.
		result = Melder_8to32(result_c);
	}
	// Melder_casual(U"number of elements left on stack: ", lua_gettop(L));
	lua_settop(L, 0);
	lua_close(L);
	return result;
}

// vi: ft=cpp:
