#include "melder.h"
#include "praat_script.h"
#include "praatP.h"
#include "luapraat.h"

static const char *LUAPRAAT_LUALIB = R"(include_str!("praat.lua");)";
Interpreter *INTERPRETER;

static int luapraat_call_praat(lua_State *L) {
	static MelderString output;
	const char *cmd_c = lua_tostring(L, 1);
	autostring32 cmd = Melder_8to32(cmd_c);

	bool should_divert = !str32nequ(cmd.get(), U"appendInfo", 10) && !str32nequ(cmd.get(), U"writeInfo", 9);
	// TODO: create an API for this buffer switch back and forth, instead
	// of directly meddling with _p_currentBuffer and _foregroundBuffer?
	MelderString *orig_current_buffer = MelderInfo::_p_currentBuffer;
	if (should_divert) {
		MelderString_empty(&output);
		// sentinel which indicates current object ID should be returned
		// instead; will be overwritten if any actual output is generated
		MelderString_appendCharacter(&output, 1);
		MelderInfo::_p_currentBuffer = &output;
	} else {
		MelderInfo::_p_currentBuffer = &MelderInfo::_foregroundBuffer;
	}

	bool cmd_failed = false;
	bool no_silent_error;
	// praat_executeCommand returns 0 if an error occurred and was
	// silenced using nocheck, 1 otherwise. The 0 shouldn't happen too
	// often, since when calling Praat from Lua, it's better to use Lua's
	// exception handling facilities: instead of `_praat("nocheck X")`, do
	// `pcall(praat.X)`.  But let's handle it the same way Interpreter.cpp
	// does, for consistency's sake.
	try {
		no_silent_error = praat_executeCommand(*INTERPRETER, cmd.get());
	} catch (MelderError) {
		cmd_failed = true;
	}
	// reset to old divert (if any, otherwise to regular info window)
	// instead of Melder_divertInfo(nullptr), which would ignore any old
	// divert
	MelderInfo::_p_currentBuffer = orig_current_buffer;
	if (cmd_failed) {
		return luaL_error(L, "Praat command failed: `%s`", cmd_c);
	}

	if (should_divert && no_silent_error) {
		if (output.string[0] == 1) {
			// this is basically copy-pasted from Interpreter.cpp -> TODO: cleanup
			int IOBJECT, selectedObject = 0, numberOfSelectedObjects = 0;
			WHERE (SELECTED) { selectedObject = IOBJECT; numberOfSelectedObjects += 1; }
			if (numberOfSelectedObjects > 1) {
				return luaL_error(L, "Multiple objects selected. Cannot assign object ID to variable.");
			} else if (numberOfSelectedObjects == 0) {
				return luaL_error(L, "No objects selected. Cannot assign object ID to variable.");
			} else {
				lua_pushnumber(L, theCurrentPraatObjects->list[selectedObject].id);
			}
		} else {
			lua_pushstring(L, Melder_32to8(output.string).get());
		}
	} else {
		lua_pushnil(L);
	}
	return 1;
}

autostring32 luapraat_run(const char32 *script_path, Interpreter *interpreter) {
	lua_State *L = luaL_newstate();
	luaL_openlibs(L);
	lua_pushcfunction(L, luapraat_call_praat);
	lua_setglobal(L, "_praat");
	luaL_dostring(L, LUAPRAAT_LUALIB);
	lua_setglobal(L, "praat");
	// TODO: is there a cleaner way to pass the interpreter to the C/Lua
	// interface function than via a global? This isn't re-entrant.
	INTERPRETER = interpreter;

	const char *script_path_fs = Melder_peek32to8_fileSystem(script_path);
	int load_error = luaL_loadfile(L, script_path_fs);
	if (load_error) {
		// If something went wrong, error message is at the top of the stack
		Melder_throw(U"Error loading Lua script ", Melder_8to32(lua_tostring(L, -1)).get());
	}

	int call_error = lua_pcall(L, 0, LUA_MULTRET, 0);
	if (call_error) {
		Melder_throw(U"Error running Lua script ", Melder_8to32(lua_tostring(L, -1)).get());
	}

	// NOTE: The conversion assumes UTF-8 output from Lua.
	autostring32 result = Melder_8to32(lua_tostring(L, -1));
	// Melder_casual(U"number of elements left on stack: ", lua_gettop(L));
	lua_settop(L, 0);
	lua_close(L);
	return result;
}

// vi: ft=cpp:
