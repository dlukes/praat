#include "melder.h"
#include "praat_script.h"
#include "praatP.h"
#include "luapraat.h"

static const char *LUAPRAAT_LUALIB = R"(include_str!("praat.lua");)";
Interpreter *INTERPRETER;

static int luapraat_call_praat(lua_State *L) {
	static MelderString output;
	const char *cmd_c = lua_tostring(L, 1);
	autostring32 cmd = Melder_8to32(cmd_c);

	bool should_divert = !str32nequ(cmd.get(), U"appendInfo", 10) && !str32nequ(cmd.get(), U"writeInfo", 9);
	// TODO: create an API for this buffer switch back and forth, instead
	// of directly meddling with _p_currentBuffer and _foregroundBuffer?
	MelderString *orig_current_buffer = MelderInfo::_p_currentBuffer;
	if (should_divert) {
		MelderString_empty(&output);
		MelderInfo::_p_currentBuffer = &output;
	} else {
		MelderInfo::_p_currentBuffer = &MelderInfo::_foregroundBuffer;
	}

	// TODO: what does the status tell us, what should we do with it?
	try {
		int status = praat_executeCommand(*INTERPRETER, cmd.get());
	} catch (MelderError) {
		return luaL_error(L, "Praat command failed: `%s`", cmd_c);
	}

	if (should_divert ) {
		if (output.string[0] == 1) {
			// sentinel which indicates current object ID should be returned
			// instead; this is basically copy-pasted from Interpreter.cpp ->
			// TODO: cleanup
			int IOBJECT, selectedObject = 0, numberOfSelectedObjects = 0;
			WHERE (SELECTED) { selectedObject = IOBJECT; numberOfSelectedObjects += 1; }
			if (numberOfSelectedObjects > 1) {
				return luaL_error(L, "Multiple objects selected. Cannot assign object ID to variable.");
			} else if (numberOfSelectedObjects == 0) {
				return luaL_error(L, "No objects selected. Cannot assign object ID to variable.");
			} else {
				lua_pushnumber(L, theCurrentPraatObjects->list[selectedObject].id);
			}
		} else if (should_divert) {
			lua_pushstring(L, Melder_32to8(output.string).get());
		}
		// reset to old divert (if any, otherwise to regular info window)
		// instead of Melder_divertInfo(nullptr), which would ignore any old
		// divert
		MelderInfo::_p_currentBuffer = orig_current_buffer;
	} else {
		lua_pushnil(L);
	}
	return 1;
}

autostring32 luapraat_run(const char32 *script_path, Interpreter *interpreter) {
	lua_State *L = luaL_newstate();
	luaL_openlibs(L);
	lua_pushcfunction(L, luapraat_call_praat);
	lua_setglobal(L, "_praat");
	luaL_dostring(L, LUAPRAAT_LUALIB);
	lua_setglobal(L, "praat");
	// TODO: is there a cleaner way to pass the interpreter to the C/Lua
	// interface function than via a global? This isn't re-entrant.
	INTERPRETER = interpreter;

	const char *script_path_fs = Melder_peek32to8_fileSystem(script_path);
	int load_error = luaL_loadfile(L, script_path_fs);
	if (load_error) {
		// If something went wrong, error message is at the top of the stack
		Melder_throw(U"Error loading Lua script ", Melder_8to32(lua_tostring(L, -1)).get());
	}

	int call_error = lua_pcall(L, 0, LUA_MULTRET, 0);
	if (call_error) {
		Melder_throw(U"Error running Lua script ", Melder_8to32(lua_tostring(L, -1)).get());
	}

	const char *result_c = lua_tostring(L, -1);
	autostring32 result;
	// If there is no output but MelderInfo is diverted (= Praat is
	// expecting a return value), signal to Praat we want to "return" the
	// current Praat object, using the sentinel value expected by
	// Interpreter_run.
	if (result_c == nullptr && MelderInfo::_p_currentBuffer != & MelderInfo::_foregroundBuffer) {
		result = Melder_8to32("\x01");
	} else {
		// NOTE: The conversion assumes UTF-8 output from Lua.
		result = Melder_8to32(result_c);
	}
	// Melder_casual(U"number of elements left on stack: ", lua_gettop(L));
	lua_settop(L, 0);
	lua_close(L);
	return result;
}

// vi: ft=cpp:
